---
layout: lecture
published: false
title: Reading data, functions, and making figures in Matlab
---


~~~ bash
$ git clone https://github.com/AOS573/matlab-week7.git

$ cd matlab-week6
~~~


# Reading data in Matlab

Matlab can be both easier and more difficult to read in data compared to Fortran and Python. Simply jumping through lines to read in a text file in Fortran or Python only takes a couple of lines of code at most, however, in Matlab, this can be seen as a semi-impossible task to do by hand. Luckily, Matlab has many built in applications that can make reading in data fairly easy. The most important thing to learn about it the `generate script`, or `generate function` command. Both of these are not really commands you call in a script or command line, but are options that you can click to, and both can give you a template for reading in many sorts of data. To find these commands, you can right-click on a text file, or csv file, click on import data, which should bring up a new interface. This new interface should have a large button saying import data, but below that, it should give you the option to generate a script or a function. In general, you will have to do this for every file type you want to read, but the relative amount of work is actually fairly low, and if you have to do it frequently enough, you will become experienced enough to build yourself a template for that. The nice thing about the scripts that matlab auto-generates is that they are actually very well commented. The example below reads in a sounding file:

~~~ matlab
%% Import data from text file.
% Script for importing data from the following text file:
%
%    C:\Users\Zach\Documents\AOS573\Matlab_scripts\MPX_sonde.txt
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2017/03/05 15:46:23

%% Initialize variables.
filename = 'C:\Users\Zach\Documents\AOS573\Matlab_scripts\MPX_sonde.txt';
startRow = 6;

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%7s%7s%7s%7s%7s%7s%7s%7s%7s%7s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
textscan(fileID, '%[^\n\r]', startRow-1, 'ReturnOnError', false);
dataArray = textscan(fileID, formatSpec, 'Delimiter', '', 'WhiteSpace', '', 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3,4,5,6,7,8,9,10,11]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
raw(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
PRES = cell2mat(raw(:, 1));
HGHT = cell2mat(raw(:, 2));
TEMP = cell2mat(raw(:, 3));
DWPT = cell2mat(raw(:, 4));
RELH = cell2mat(raw(:, 5));
MIXR = cell2mat(raw(:, 6));
DRCT = cell2mat(raw(:, 7));
SKNT = cell2mat(raw(:, 8));
THTA = cell2mat(raw(:, 9));
THTE = cell2mat(raw(:, 10));
THTV = cell2mat(raw(:, 11));


%% Clear temporary variables
clearvars filename startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp me R;
~~~

The previous script read in a .txt file, but the same methodology can be applied for reading in an excel file, .dat file, as well as a few other file types. There are also some well organized and documented file types such as HDF and netCDF that recent versions of Matlab have built-in functions for reading in, but even older versions can read with the appropriate extension.

# Functions

Notice that the previous script was custiomized to load in a specific sounding .txt file. If we wanted to generalize this script to load in various sounding files, you would turn this script into a function. Functions in Matlab encompass both of what functions and subroutines were in Fortran. Functions in matlab have the same intended uses as those in Fortran, and in general, they are very useful for compartamentalizing your code. Any sort of math, or loading, or even figure making can be generalized into a function to be used again in the future. You create a function file in the same way you write a script in matlab, except that you provide some specifications at the beginning of the script:

~~~ matlab
function [variables] = function_name(inputs)
~~~

Note that this is the top of the script, you're telling matlab that this script is a function, it has outputs that in this case are `variables`, has a function name called `function_name`, and has inputs with the name `inputs`. The previous script can be generalized into a function as follows:

~~~ matlab
function [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] = importfilesnd(filename, startRow, endRow)
%IMPORTFILE Import numeric data from a text file as column vectors.
%   [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] =
%   IMPORTFILE(FILENAME) Reads data from text file FILENAME for the default
%   selection.
%
%   [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] =
%   IMPORTFILE(FILENAME, STARTROW, ENDROW) Reads data from rows STARTROW
%   through ENDROW of text file FILENAME.
%
% Example:
%   [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] =
%   importfile('MPX_sonde.txt',6, 171);
%
%    See also TEXTSCAN.

% Auto-generated by MATLAB on 2017/03/05 16:01:00

%% Initialize variables.
if nargin ==1 || nargin == 2
    startRow = 6;
    endRow = inf;
end

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%7s%7s%7s%7s%7s%7s%7s%7s%7s%7s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
textscan(fileID, '%[^\n\r]', startRow(1)-1, 'ReturnOnError', false);
dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', '', 'WhiteSpace', '', 'ReturnOnError', false);
for block=2:length(startRow)
    frewind(fileID);
    textscan(fileID, '%[^\n\r]', startRow(block)-1, 'ReturnOnError', false);
    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', '', 'WhiteSpace', '', 'ReturnOnError', false);
    for col=1:length(dataArray)
        dataArray{col} = [dataArray{col};dataArrayBlock{col}];
    end
end

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3,4,5,6,7,8,9,10,11]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
raw(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
PRES = cell2mat(raw(:, 1));
HGHT = cell2mat(raw(:, 2));
TEMP = cell2mat(raw(:, 3));
DWPT = cell2mat(raw(:, 4));
RELH = cell2mat(raw(:, 5));
MIXR = cell2mat(raw(:, 6));
DRCT = cell2mat(raw(:, 7));
SKNT = cell2mat(raw(:, 8));
THTA = cell2mat(raw(:, 9));
THTE = cell2mat(raw(:, 10));
THTV = cell2mat(raw(:, 11));

~~~

If you write something similar to this in the Matlab editor, you will notice that Matlab treats functions in a way that is similar to a loop. However, generated functions in matlab do not have an `end` at the end. Matlab is fairly gentle in this aspect, and you can end your functions however you like.

# Combining reading in data, functions, statistics, and figure making

Lets put together what we have learned in this class so far, and learn a few more applications of statistics in matlab. This script will require the two files you downloaded from github.

~~~ matlab
% reading, statistics, and plotting, by Zach Hansen

clear all
close all

load sfc_rain_573.mat

~~~

This script so far gives our standard route of clearing previous data, and loading some data called `SFC_RAIN.mat`. As I said in last class, `.mat` files are the easiest to read in for matlab, but are not really useful for anything else. This file gives us mean surface rain from 2000-2013. We can see two other variables included in this script, `sfc_lon` and `sfc_lat`, which as you may expect are the range of longitudes and latitudes for our data. We can see that this is a fairly high resolution, prehaps too high to comfortably generate images on an old computer, but we can interpolate our data to a lower resolution.


~~~ matlab

int = 0.5; % our horizontal resolution

nlat = (-37+int/2):int:(37-int/2); % new latitudes
nlon = (-180+int/2):int:(180-int/2); % new longitudes

sfc_rain_new = interp2(sfc_lon,sfc_lat,SFC_RAIN,nlon,nlat'); % note that the "'" re-oirients that variable
~~~

The above scripts define a new latitude and logitude array with a lower resolution that was had previously. We then used the `interp2` command to interpolate the 2D matrix that is SFC_RAIN into one that has a lower resolution. Feel free to try this out with a variety of `int` values.

Let's turn this into an image using the imagesc command:

~~~ matlab
figure(1)

imagesc(nlon,nlat,sfc_rain_new)
~~~

Note that a quirk of imagesc is that it reverses the y-axis. To fix this, we can use the statment `set(gca,'ydir','normal')`.

My preferred way to make images is to use the contour fill command `contourf` this command allows you to specify the range of values that you want to display, makes NaN's white, and when you turn off the contour edges, we can get a very nice image.


~~~ matlab
figure(1)

contourf(nlon,nlat,sfc_rain_new,0:0.25:10,'edgecolor','none')

~~~

Note that where we are specifying the range of contour values, we shouldn't use a range that has a greater number of values than matlab has colors loaded. To find the number of colors loaded, type `colormap` and the number of rows will be the total number of colors available. You can also create your own colormaps that have a greater number of colors, and the just specify matlab to use it by typing `colormap(my_cmap)` where `my_cmap` is the colormap you have created.

So we have a feel for what our data looks like now, let's quantify it in some useful ways. Maybe the most basic way would be to create a probability distribution function of this data. To do that, we will need to reshape our matrix into a single row or column.

~~~ matlab
sr_size = size(sfc_rain_new);

sr_col = reshape(sfc_rain_new,sr_size(1)*sr_size(2),1);
~~~

So now all our precipitation data is in a single column, we can use the histc command to find the counts of specific bins that we have specified. We should look at the max and min of the data to find a reasonable range of bins. NOTE!!! More recent versions of matlab have replaced histc with histcounts, which has better functionality, the following stuff should be the same between both.

~~~ matlab
edges = 0:0.25:22.5

N = histc(sr_col,edges);
~~~
This gives the counts for all of our bins, if we wanted then in precentage, the we should divide N by the length of sr_col.

~~~ matlab
pr_N = N/length(sr_col)

~~~
We can plot this using a bar graph, or a line plot. One tricky thing is that older versions of matlab don't really recognize that the data associated with an individual edge is actually inbetween two edges. Recent versions of matlab allow a `'histc'` modifier into many plotting functions, but old ones do not. However, we can modify our edges to make plots more reasonable.

~~~ matlab
inter = 0.25;
plot_edge = (0+inter/2):inter:(22.5-inter/2);
plot_edge = [plot_edge, 22.5]; % recognize that histc does the weird thing of counting data in the final plot edge.
~~~

We can turn our data into a cumulative distribution function by using the cumsum command on our variable pr_N. This allows us another view on how our distribution is defined. Let's also plot these various distributions.

~~~ matlab
cs_N = cumsum(pr_N);
plot(plot_edge,cs_N)
~~~

Now, if we wanted to look at how the extremes of this figure change, we might want to use a logarithmic scale. However, currently, everything falls within one log of our values, so what we really want to see is `1-cs_N`.

~~~ matlab
plot(plot_edge,1-cs_N)
set(gca,'yscale','log')
~~~

Now, if we subtract any of these values from 1, we can see what percentile they are associated with. i.e. 10^-3 is the 99.9% value of extremity. Another way to find a single percentile is to use the `prctile` command. In general, with the above techniques, you should be able to load in many file types, and then display their data, and quantify their distributions of data.

# Lab Assignment
[Follow this link to our assignment](/assignments/7-matlab2.html).
