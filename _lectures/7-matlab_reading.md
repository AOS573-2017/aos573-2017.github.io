---
layout: lecture
published: false
title: Reading data, functions, and making figures in Matlab
---

# Reading data in Matlab

Matlab can be both easier and more difficult to read in data compared to Fortran and Python. Simply jumping through lines to read in a text file in Fortran or Python only takes a couple of lines of code at most, however, in Matlab, this can be seen as a semi-impossible task to do by hand. Luckily, Matlab has many built in applications that can make reading in data fairly easy. The most important thing to learn about it the `generate script`, or `generate function` command. Both of these are not really commands you call in a script or command line, but are options that you can click to, and both can give you a template for reading in many sorts of data. To find these commands, you can right-click on a text file, or csv file, click on import data, which should bring up a new interface. This new interface should have a large button saying import data, but below that, it should give you the option to generate a script or a function. In general, you will have to do this for every file type you want to read, but the relative amount of work is actually fairly low, and if you have to do it frequently enough, you will become experienced enough to build yourself a template for that. The nice thing about the scripts that matlab auto-generates is that they are actually very well commented. The example below reads in a sounding file:

~~~ matlab
%% Import data from text file.
% Script for importing data from the following text file:
%
%    C:\Users\Zach\Documents\AOS573\Matlab_scripts\MPX_sonde.txt
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2017/03/05 15:46:23

%% Initialize variables.
filename = 'C:\Users\Zach\Documents\AOS573\Matlab_scripts\MPX_sonde.txt';
startRow = 6;

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%7s%7s%7s%7s%7s%7s%7s%7s%7s%7s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
textscan(fileID, '%[^\n\r]', startRow-1, 'ReturnOnError', false);
dataArray = textscan(fileID, formatSpec, 'Delimiter', '', 'WhiteSpace', '', 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3,4,5,6,7,8,9,10,11]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
raw(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
PRES = cell2mat(raw(:, 1));
HGHT = cell2mat(raw(:, 2));
TEMP = cell2mat(raw(:, 3));
DWPT = cell2mat(raw(:, 4));
RELH = cell2mat(raw(:, 5));
MIXR = cell2mat(raw(:, 6));
DRCT = cell2mat(raw(:, 7));
SKNT = cell2mat(raw(:, 8));
THTA = cell2mat(raw(:, 9));
THTE = cell2mat(raw(:, 10));
THTV = cell2mat(raw(:, 11));


%% Clear temporary variables
clearvars filename startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp me R;
~~~

The previous script read in a .txt file, but the same methodology can be applied for reading in an excel file, .dat file, as well as a few other file types. There are also some well organized and documented file types such as HDF and netCDF that recent versions of Matlab have built-in functions for reading in, but even older versions can read with the appropriate extension.

# Functions

Notice that the previous script was custiomized to load in a specific sounding .txt file. If we wanted to generalize this script to load in various sounding files, you would turn this script into a function. Functions in Matlab encompass both of what functions and subroutines were in Fortran. You create a function file in the same way you write a script in matlab, except that you provide some specifications at the beginning of the script:

~~~ matlab
function [variables] = function_name(inputs)
~~~

Note that this is the top of the script, you're telling matlab that this script is a function, it has outputs that in this case are `variables`, has a function name called `function_name`, and has inputs with the name `inputs`.
