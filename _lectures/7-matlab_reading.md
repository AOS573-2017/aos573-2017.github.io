---
layout: lecture
published: false
title: Reading data, functions, and making figures in Matlab
---

# Reading data in Matlab

Matlab can be both easier and more difficult to read in data compared to Fortran and Python. Simply jumping through lines to read in a text file in Fortran or Python only takes a couple of lines of code at most, however, in Matlab, this can be seen as a semi-impossible task to do by hand. Luckily, Matlab has many built in applications that can make reading in data fairly easy. The most important thing to learn about it the `generate script`, or `generate function` command. Both of these are not really commands you call in a script or command line, but are options that you can click to, and both can give you a template for reading in many sorts of data. To find these commands, you can right-click on a text file, or csv file, click on import data, which should bring up a new interface. This new interface should have a large button saying import data, but below that, it should give you the option to generate a script or a function. In general, you will have to do this for every file type you want to read, but the relative amount of work is actually fairly low, and if you have to do it frequently enough, you will become experienced enough to build yourself a template for that. The nice thing about the scripts that matlab auto-generates is that they are actually very well commented. The example below reads in a sounding file:

~~~ matlab
%% Import data from text file.
% Script for importing data from the following text file:
%
%    C:\Users\Zach\Documents\AOS573\Matlab_scripts\MPX_sonde.txt
%
% To extend the code to different selected data or a different text file,
% generate a function instead of a script.

% Auto-generated by MATLAB on 2017/03/05 15:46:23

%% Initialize variables.
filename = 'C:\Users\Zach\Documents\AOS573\Matlab_scripts\MPX_sonde.txt';
startRow = 6;

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%7s%7s%7s%7s%7s%7s%7s%7s%7s%7s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
textscan(fileID, '%[^\n\r]', startRow-1, 'ReturnOnError', false);
dataArray = textscan(fileID, formatSpec, 'Delimiter', '', 'WhiteSpace', '', 'ReturnOnError', false);

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3,4,5,6,7,8,9,10,11]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
raw(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
PRES = cell2mat(raw(:, 1));
HGHT = cell2mat(raw(:, 2));
TEMP = cell2mat(raw(:, 3));
DWPT = cell2mat(raw(:, 4));
RELH = cell2mat(raw(:, 5));
MIXR = cell2mat(raw(:, 6));
DRCT = cell2mat(raw(:, 7));
SKNT = cell2mat(raw(:, 8));
THTA = cell2mat(raw(:, 9));
THTE = cell2mat(raw(:, 10));
THTV = cell2mat(raw(:, 11));


%% Clear temporary variables
clearvars filename startRow formatSpec fileID dataArray ans raw col numericData rawData row regexstr result numbers invalidThousandsSeparator thousandsRegExp me R;
~~~

The previous script read in a .txt file, but the same methodology can be applied for reading in an excel file, .dat file, as well as a few other file types. There are also some well organized and documented file types such as HDF and netCDF that recent versions of Matlab have built-in functions for reading in, but even older versions can read with the appropriate extension.

# Functions

Notice that the previous script was custiomized to load in a specific sounding .txt file. If we wanted to generalize this script to load in various sounding files, you would turn this script into a function. Functions in Matlab encompass both of what functions and subroutines were in Fortran. Functions in matlab have the same intended uses as those in Fortran, and in general, they are very useful for compartamentalizing your code. Any sort of math, or loading, or even figure making can be generalized into a function to be used again in the future. You create a function file in the same way you write a script in matlab, except that you provide some specifications at the beginning of the script:

~~~ matlab
function [variables] = function_name(inputs)
~~~

Note that this is the top of the script, you're telling matlab that this script is a function, it has outputs that in this case are `variables`, has a function name called `function_name`, and has inputs with the name `inputs`. The previous script can be generalized into a function as follows:

~~~ matlab
function [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] = importfilesnd(filename, startRow, endRow)
%IMPORTFILE Import numeric data from a text file as column vectors.
%   [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] =
%   IMPORTFILE(FILENAME) Reads data from text file FILENAME for the default
%   selection.
%
%   [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] =
%   IMPORTFILE(FILENAME, STARTROW, ENDROW) Reads data from rows STARTROW
%   through ENDROW of text file FILENAME.
%
% Example:
%   [PRES,HGHT,TEMP,DWPT,RELH,MIXR,DRCT,SKNT,THTA,THTE,THTV] =
%   importfile('MPX_sonde.txt',6, 171);
%
%    See also TEXTSCAN.

% Auto-generated by MATLAB on 2017/03/05 16:01:00

%% Initialize variables.
if nargin<=2
    startRow = 6;
    endRow = inf;
end

%% Read columns of data as strings:
% For more information, see the TEXTSCAN documentation.
formatSpec = '%7s%7s%7s%7s%7s%7s%7s%7s%7s%7s%s%[^\n\r]';

%% Open the text file.
fileID = fopen(filename,'r');

%% Read columns of data according to format string.
% This call is based on the structure of the file used to generate this
% code. If an error occurs for a different file, try regenerating the code
% from the Import Tool.
textscan(fileID, '%[^\n\r]', startRow(1)-1, 'ReturnOnError', false);
dataArray = textscan(fileID, formatSpec, endRow(1)-startRow(1)+1, 'Delimiter', '', 'WhiteSpace', '', 'ReturnOnError', false);
for block=2:length(startRow)
    frewind(fileID);
    textscan(fileID, '%[^\n\r]', startRow(block)-1, 'ReturnOnError', false);
    dataArrayBlock = textscan(fileID, formatSpec, endRow(block)-startRow(block)+1, 'Delimiter', '', 'WhiteSpace', '', 'ReturnOnError', false);
    for col=1:length(dataArray)
        dataArray{col} = [dataArray{col};dataArrayBlock{col}];
    end
end

%% Close the text file.
fclose(fileID);

%% Convert the contents of columns containing numeric strings to numbers.
% Replace non-numeric strings with NaN.
raw = repmat({''},length(dataArray{1}),length(dataArray)-1);
for col=1:length(dataArray)-1
    raw(1:length(dataArray{col}),col) = dataArray{col};
end
numericData = NaN(size(dataArray{1},1),size(dataArray,2));

for col=[1,2,3,4,5,6,7,8,9,10,11]
    % Converts strings in the input cell array to numbers. Replaced non-numeric
    % strings with NaN.
    rawData = dataArray{col};
    for row=1:size(rawData, 1);
        % Create a regular expression to detect and remove non-numeric prefixes and
        % suffixes.
        regexstr = '(?<prefix>.*?)(?<numbers>([-]*(\d+[\,]*)+[\.]{0,1}\d*[eEdD]{0,1}[-+]*\d*[i]{0,1})|([-]*(\d+[\,]*)*[\.]{1,1}\d+[eEdD]{0,1}[-+]*\d*[i]{0,1}))(?<suffix>.*)';
        try
            result = regexp(rawData{row}, regexstr, 'names');
            numbers = result.numbers;
            
            % Detected commas in non-thousand locations.
            invalidThousandsSeparator = false;
            if any(numbers==',');
                thousandsRegExp = '^\d+?(\,\d{3})*\.{0,1}\d*$';
                if isempty(regexp(thousandsRegExp, ',', 'once'));
                    numbers = NaN;
                    invalidThousandsSeparator = true;
                end
            end
            % Convert numeric strings to numbers.
            if ~invalidThousandsSeparator;
                numbers = textscan(strrep(numbers, ',', ''), '%f');
                numericData(row, col) = numbers{1};
                raw{row, col} = numbers{1};
            end
        catch me
        end
    end
end


%% Replace non-numeric cells with NaN
R = cellfun(@(x) ~isnumeric(x) && ~islogical(x),raw); % Find non-numeric cells
raw(R) = {NaN}; % Replace non-numeric cells

%% Allocate imported array to column variable names
PRES = cell2mat(raw(:, 1));
HGHT = cell2mat(raw(:, 2));
TEMP = cell2mat(raw(:, 3));
DWPT = cell2mat(raw(:, 4));
RELH = cell2mat(raw(:, 5));
MIXR = cell2mat(raw(:, 6));
DRCT = cell2mat(raw(:, 7));
SKNT = cell2mat(raw(:, 8));
THTA = cell2mat(raw(:, 9));
THTE = cell2mat(raw(:, 10));
THTV = cell2mat(raw(:, 11));

~~~
If you write something similar to this in the Matlab editor, you will notice that Matlab treats functions in a way that is similar to a loop. However, generated functions in matlab do not have an `end` at the end. Matlab is fairly gentle in this aspect, and you can end your functions however you like.

# Combining reading in data, functions, statistics, and figure making

Lets put together what we have learned in this class so far, and learn a few more applications of statistics in matlab. This script will require the two files you downloaded from github.

~~~ matlab
% reading, stating, and plotting, by Zach Hansen

clear all
close all

load sfc_rain_573.mat

~~~

This script so far gives our standard route of clearing previous data, and loading some data called `SFC_RAIN.mat`. As I said in last class, `.mat` files are the easiest to read in for matlab, but are not really useful for anything else. This file gives us mean surface rain from 2000-2013. We can see two other variables included in this script, `sfc_lon` and `sfc_lat`, which as you may expect are the range of longitudes and latitudes for our data. We can see that this is a fairly high resolution, prehaps too high to comfortably generate images on an old computer, but we can interpolate our data to a lower resolution.


~~~ matlab

sfc_lon = sfc_lon-180; % re-orient our longitudes

int = 0.5; % our horizontal resolution

nlat = (-37+int/2):int:(37-int/2); % new latitudes
nlon = (-180+int/2):int:(180-int/2); % new longitudes

sfc_rain_new = interp2(sfc_lon,sfc_lat,SFC_RAIN,nlon,nlat');


